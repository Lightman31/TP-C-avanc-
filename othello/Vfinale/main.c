#include <stdlib.h>#include <sys/types.h>#ifdef MINGW32// Libraries for Windows#include<winsock2.h>#include <windows.h> #else// Libraries for Linux#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#define INVALID_SOCKET -1#define SOCKET_ERROR -1#define closesocket(s) close(s)typedef int SOCKET;typedef struct sockaddr_in SOCKADDR_IN;typedef struct sockaddr SOCKADDR;typedef struct in_addr IN_ADDR;#endif#include <string.h>#include <stdio.h>#include <unistd.h>#include <stdbool.h>#include"traitement.h"// messages constants#define BUFFER_SIZE 1024#define PORT 8888#define IP_SERVER 137.74.113.61#define MAX_CLIENT 1#define BLACK_PLAYER 0x01#define WHITE_PLAYER 0x02#define NOK_RESPONSE 0x00#define OK_RESPONSE 0x01#define SYNCRO 0x55#define FIELDSIZE 8void sendMessage(SOCKET sock, const char *ecrit, int nbOctet);typedef struct{    int port;    char name;}Client;typedef struct{    SOCKET sock;    char name[BUFFER_SIZE];}Cliente;int init_connection(void){    SOCKET sock_client;    SOCKADDR_IN server;	#ifdef MINGW32	WSADATA wsa;	// code for windows only    printf("\nInitialising Winsock...");    if(WSAStartup(MAKEWORD(2,2),&wsa) != 0)    {        printf("Failed. Error Code : %d",WSAGetLastError());        return 1;    }#endif    //Create socket    sock_client = socket(AF_INET, SOCK_STREAM, 0);    if (sock_client == INVALID_SOCKET) {        printf("Could not create socket");        exit (EXIT_FAILURE);    }    puts("Client Socket created");    // Define the socket remote address : 192.168.0.111:8888    server.sin_addr.s_addr = inet_addr("127.0.0.1");    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    //Connect to remote server    if (connect(sock_client, (SOCKADDR *) &server, sizeof(server)) < 0) {        perror("connect failed. Error");        exit (EXIT_FAILURE);    }    puts("Connected\n");    return sock_client;}void connect_message(SOCKET sock, char *name){    //Variables locales    char message[100], server_reply[2000];    int e, i, playerColor;    char CRC = 0;    // Create the "Connect Message"    message[0] = SYNCRO;  // Synchro    message[1] = strlen(name)+1; // Message Length    message[2] = CONNECT_MESSAGE;  // Connect message    message[3] = strlen(name);  // Name Length    //Récupération du nom    for(i=4; i < (strlen(name)+4); i++)        message[i] = name[i-4];    //Calcul du CRC lors du choix du nom    for (e = 2; e < (strlen(name)+4); e++)        CRC += message[e];    message[strlen(name)+4] = CRC;    // Send "connect message" to the GM    sendMessage(sock, message, (strlen(name)+5));}void sendMessage(SOCKET sock, const char *ecrit, int nbOctet) {    //Variables locales    int l = 0;    int fin;    //En cas d'erreur lors de l'envoi    if (send (sock, ecrit, nbOctet, 0) < 0)    {        printf ("Error : When sending new message\n");    }    //Affichage du message envoyé    printf("Message sent : ");    fin = (int) ecrit[1]+4;    for (l = 0; l < fin ; l++) {        printf(" %x ", ecrit[l]);    }    printf("\n");}int menu_message (SOCKET sock_client, char corps[1000], int message_type, int message_len, int playerColor){    printf ("\nmenu message : ");    char depx = 50, depy = 50;    char message[100];    if (message_type == 0x10)     {        //printf("Type de message : couleur");        playerColor = message_couleur(corps, playerColor);    }    else if (message_type == OKNOK_MESSAGE)     {        printf("Type de message : OK/NOK : il faut répondre OK (OxO1)\n");        // Create the "Connect Message"        message[0] = 0x55;  // Synchro        message[1] = 1;  // Synchro        message[2] = 0x02;  // Synchro        message[3] = 0x01;  // Synchro        message[4] = ( 0x01 + 0x02 ) & 0xff;         sendMessage(sock_client, message, 5);    }    else if (message_type == NEXTTURN_MESSAGE)     {        //printf("Type de message : NEXTTURN_MESSAGE : il faut analyser le tab");        decouvrir_tab(corps,message_len, playerColor,&depx,&depy);        //printf ("\ndepx = %d\ndepy = %d\n",depx,depy);        //printf("\non envoie un message ?");        if (depx != 50) // on envoie un message !!        {            //printf("\noui !!! \n");            printf ("\ndepx = %d\ndepy = %d\n",depx,depy);        // Create the "Connect Message"        message[0] = 0x55;  // Synchro        message[1] = 2;  // Synchro        message[2] = 0x03;  // Synchro        message[3] = depx;  // Synchro        message[4] = depy;          message[5] = ( depy + depx + 0x03 ) & 0xff;         sendMessage(sock_client, message, 6);        }        //printf("\ncoup joue");    }    else     {        printf("Type de message inconnu : 0x%x\n", message_type);    }    return playerColor;}int get_message(SOCKET sock_client, int playerColor){    char buff[1];    char corps[1000];    int message_len;    int message_type;    int checksum;    /// SYNCHRO    if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message Synchro\n");    if (buff[0] == 0x55) printf("\nNew message ");    else exit (0);    /// TAILLE DU Message    if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message LENGHT\n");    message_len = buff[0];    /// TYPE DE MESSAGE     if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message TYPE\n");    message_type = buff[0];    /*    if (message_type == 0x10) printf("\nType de message : couleur");    else if (message_type == 0x02) printf("\nType de message : OK/NOK : il faut répondre OK (OxO1)");    else printf("\nType de message : 0x%x", buff[0]);    */    /// Recuperation du CORPS DU Message    if (read ( sock_client , corps, message_len) < 0) printf (" ");    /// CHECKSUM    if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message checksum\n");    printf(" ");    /// calcul du checksum mesuré    checksum = calc_checksum(message_type,message_len,corps);//printf("checksum recu : 0x%x\nchecksum calcule : 0x%x\n", buff[0] & 0x000000ff , checksum);    if (( buff[0] & 0x000000ff ) == checksum)     {    }    else     {        printf("\nCHECKSUM PAS OK\n");        exit(0);    }    /// tout est bon, on peut donc maintenant regarder le message     playerColor = menu_message(sock_client, corps, message_type, message_len, playerColor);    return playerColor;}//inet_addrint main(int argc, char *argv[]) {	int playerColor;	SOCKET sock_client = init_connection();		connect_message(sock_client, argv[1]);	while (1)	{		playerColor = get_message(sock_client, playerColor);	}	sleep(5);    return 0;}