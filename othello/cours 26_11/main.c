#include <stdlib.h>#include <sys/types.h>#ifdef MINGW32// Libraries for Windows#include<winsock2.h>#include <windows.h> #else// Libraries for Linux#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#define INVALID_SOCKET -1#define SOCKET_ERROR -1#define closesocket(s) close(s)typedef int SOCKET;typedef struct sockaddr_in SOCKADDR_IN;typedef struct sockaddr SOCKADDR;typedef struct in_addr IN_ADDR;#endif#include <string.h>#include <stdio.h>#include <unistd.h>#include <stdbool.h>// messages constants#define BUFFER_SIZE 1024#define PORT 8888#define IP_SERVER 127.0.0.1#define MAX_CLIENT 1#define BLACK_PLAYER 0x01#define WHITE_PLAYER 0x02#define NOK_RESPONSE 0x00#define OK_RESPONSE 0x01#define SYNCRO 0x55#define FIELDSIZE 8#define OKNOK_MESSAGE 0x02#define CONNECT_MESSAGE 0x01#define PLAYEROK_MESSAGE 0x10#define NEWMOVE_MESSAGE 0x03#define END_MESSAGE 0x04#define NEXTTURN_MESSAGE 0x05#define STATUS1_MESSAGE 0x06#define STATUS2_MESSAGE 0x07#define CONTROL_MESSAGE 0x08#define PING_MESSAGE 0x11typedef struct{    int port;    char name;}Client;typedef struct{    SOCKET sock;    char name[BUFFER_SIZE];}Cliente;int init_connection(void){    SOCKET sock_client;    SOCKADDR_IN server;	#ifdef MINGW32	WSADATA wsa;	// code for windows only    printf("\nInitialising Winsock...");    if(WSAStartup(MAKEWORD(2,2),&wsa) != 0)    {        printf("Failed. Error Code : %d",WSAGetLastError());        return 1;    }#endif    //Create socket    sock_client = socket(AF_INET, SOCK_STREAM, 0);    if (sock_client == INVALID_SOCKET) {        printf("Could not create socket");        exit (EXIT_FAILURE);    }    puts("Client Socket created");    // Define the socket remote address : 192.168.0.111:8888    server.sin_addr.s_addr = inet_addr("127.0.0.1");    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    //Connect to remote server    if (connect(sock_client, (SOCKADDR *) &server, sizeof(server)) < 0) {        perror("connect failed. Error");        exit (EXIT_FAILURE);    }    puts("Connected\n");    return sock_client;}void sendMessage(SOCKET sock, const char *ecrit, int nbOctet) {    //Variables locales    int l = 0;    int fin;    //En cas d'erreur lors de l'envoi    if (send (sock, ecrit, nbOctet, 0) < 0)    {        printf ("Error : When sending new message\n");    }    //Affichage du message envoyé    printf("Message sent : ");    fin = (int) ecrit[1]+4;    for (l = 0; l < fin ; l++) {        printf(" %x ", ecrit[l]);    }    printf("\n");}int connect_message(SOCKET sock, char *name){    //Variables locales    char message[100], server_reply[2000];    int e, i, playerColor;    char CRC = 0;    // Create the "Connect Message"    message[0] = SYNCRO;  // Synchro    message[1] = strlen(name)+1; // Message Length    message[2] = CONNECT_MESSAGE;  // Connect message    message[3] = strlen(name);  // Name Length    //Récupération du nom    for(i=4; i < (strlen(name)+4); i++)        message[i] = name[i-4];    //Calcul du CRC lors du choix du nom    for (e = 2; e < (strlen(name)+4); e++)        CRC += message[e];    message[strlen(name)+4] = CRC;    // Send "connect message" to the GM    sendMessage(sock, message, (strlen(name)+5));}int calc_checksum (int message_type, int message_len, char corps[1000]){	int checksum;	int i;	checksum = message_type;	for (i = 0 ; i < message_len ; i++) 	{		checksum += corps[i];	}	checksum = checksum & 0xffffffff;	return checksum;}int message_couleur(char corps[1000], int playerColor){	if (corps[0] == 0x01)	{		printf ("\n je suis le joueur noir");	}	else if (corps[0] == 0x02)	{		printf("\nje suis le joueur blanc");	}	else printf("\ncouleur inconnu");	return playerColor;}int menu_message (SOCKET sock_client, char corps[1000], int message_type, int message_len, int playerColor){	printf ("\nmenu message : ");	if (message_type == 0x10) 	{		printf("Type de message : couleur");		playerColor = message_couleur(corps, playerColor);	}	else if (message_type == 0x02) 	{		printf("Type de message : OK/NOK : il faut répondre OK (OxO1)");	}	else 	{		printf("Type de message inconnu : %x", message_type);	}	return playerColor;}int get_message(SOCKET sock_client, int playerColor){	char buff[1];	char corps[1000];	int message_len;	int message_type;	int checksum;	/// SYNCHRO	if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message\n");    if (buff[0] == 0x55) printf("\nSynchro : OK");    else     {    	printf("\n\nPROBLEME AVEC LA SYCHRO\n");   		exit (0);   	}    /// TAILLE DU Message	if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message\n");	printf("\nTaille du message = Ox%x = %d", buff[0], buff[0]);	message_len = buff[0];	/// TYPE DE MESSAGE 	if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message\n");	message_type = buff[0];	if (message_type == 0x10) printf("\nType de message : couleur");	else if (message_type == 0x02) printf("\nType de message : OK/NOK : il faut répondre OK (OxO1)");	else printf("\nType de message : %x", buff[0]);	/// Recuperation du CORPS DU Message	if (read ( sock_client , corps, message_len) < 0) printf ("Error : When reciveing new message\n");	/// CHECKSUM	if (read ( sock_client , buff, 1) < 0) printf ("Error : When reciveing new message\n");	printf("\nCHECKSUM reçu : %x", buff[0]&0xffffffff);	/// calcul du checksum mesuré	checksum = calc_checksum(message_type,message_len,corps);	printf("  ..  CHECKSUM mesuré : %x", checksum);	if (( buff[0] & 0xffffffff ) == checksum) 	{		printf("\ntout est bon avec le checksum ");	}	else 	{		printf("\n\n\nPROBLEME DE CHECKSUM\n");		exit(0);	}	/// tout est bon, on peut donc maintenant regarder le message 	playerColor = menu_message(sock_client, corps, message_type, message_len, playerColor);    return playerColor;}//inet_addrint main(int argc, char *argv[]) {	int playerColor;	SOCKET sock_client = init_connection();		connect_message(sock_client, argv[1]);	while (1)	{		playerColor = get_message(sock_client, playerColor);	}	// sleep(10);    return 0;}